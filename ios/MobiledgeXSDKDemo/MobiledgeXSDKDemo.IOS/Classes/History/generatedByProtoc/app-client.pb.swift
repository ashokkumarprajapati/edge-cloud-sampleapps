// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: app-client.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

// Device service APIs

import Foundation
//import SwiftProtobuf  // JT 18.11.10

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum DistributedMatchEngine_IDTypes: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case idUndefined // = 0
  case imei // = 1
  case msisdn // = 2
  case ipaddr // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .idUndefined
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .idUndefined
    case 1: self = .imei
    case 2: self = .msisdn
    case 3: self = .ipaddr
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .idUndefined: return 0
    case .imei: return 1
    case .msisdn: return 2
    case .ipaddr: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension DistributedMatchEngine_IDTypes: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [DistributedMatchEngine_IDTypes] = [
    .idUndefined,
    .imei,
    .msisdn,
    .ipaddr,
  ]
}

#endif  // swift(>=4.2)

enum DistributedMatchEngine_ReplyStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case rsUndefined // = 0
  case rsSuccess // = 1
  case rsFail // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .rsUndefined
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .rsUndefined
    case 1: self = .rsSuccess
    case 2: self = .rsFail
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .rsUndefined: return 0
    case .rsSuccess: return 1
    case .rsFail: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension DistributedMatchEngine_ReplyStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [DistributedMatchEngine_ReplyStatus] = [
    .rsUndefined,
    .rsSuccess,
    .rsFail,
  ]
}

#endif  // swift(>=4.2)

struct DistributedMatchEngine_RegisterClientRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// API version
  var ver: UInt32 = 0

  /// App Developer Name
  var devName: String = String()

  /// App Name
  var appName: String = String()

  /// App Version
  var appVers: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct DistributedMatchEngine_RegisterClientReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// API version
  var ver: UInt32 = 0

  /// Status of the reply
  var status: DistributedMatchEngine_ReplyStatus = .rsUndefined

  /// Session Cookie to be used in later API calls
  var sessionCookie: String = String()

  /// URI for Token Server
  var tokenServerUri: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct DistributedMatchEngine_FindCloudletRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// API version
  var ver: UInt32 {
    get {return _storage._ver}
    set {_uniqueStorage()._ver = newValue}
  }

  /// Session Cookie from RegisterClientRequest
  var sessionCookie: String {
    get {return _storage._sessionCookie}
    set {_uniqueStorage()._sessionCookie = newValue}
  }

  /// The carrier name that user is connected to ("Cellular Carrier Name")
  var carrierName: String {
    get {return _storage._carrierName}
    set {_uniqueStorage()._carrierName = newValue}
  }

  /// The GPS location of the user
  var gpsLocation: DistributedMatchEngine_Loc {
    get {return _storage._gpsLocation ?? DistributedMatchEngine_Loc()}
    set {_uniqueStorage()._gpsLocation = newValue}
  }
  /// Returns true if `gpsLocation` has been explicitly set.
  var hasGpsLocation: Bool {return _storage._gpsLocation != nil}
  /// Clears the value of `gpsLocation`. Subsequent reads from it will return its default value.
  mutating func clearGpsLocation() {_uniqueStorage()._gpsLocation = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct DistributedMatchEngine_FindCloudletReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// API version
  var ver: UInt32 {
    get {return _storage._ver}
    set {_uniqueStorage()._ver = newValue}
  }

  /// Status return
  var status: DistributedMatchEngine_FindCloudletReply.FindStatus {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  /// Full Qualified Domain Name of Closest App instance
  var fqdn: String {
    get {return _storage._fqdn}
    set {_uniqueStorage()._fqdn = newValue}
  }

  /// List of ports and L7 paths to connect to App instance
  var ports: [DistributedMatchEngine_AppPort] {
    get {return _storage._ports}
    set {_uniqueStorage()._ports = newValue}
  }

  /// Location of the cloudlet
  var cloudletLocation: DistributedMatchEngine_Loc {
    get {return _storage._cloudletLocation ?? DistributedMatchEngine_Loc()}
    set {_uniqueStorage()._cloudletLocation = newValue}
  }
  /// Returns true if `cloudletLocation` has been explicitly set.
  var hasCloudletLocation: Bool {return _storage._cloudletLocation != nil}
  /// Clears the value of `cloudletLocation`. Subsequent reads from it will return its default value.
  mutating func clearCloudletLocation() {_uniqueStorage()._cloudletLocation = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum FindStatus: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case findUnknown // = 0
    case findFound // = 1
    case findNotfound // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .findUnknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .findUnknown
      case 1: self = .findFound
      case 2: self = .findNotfound
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .findUnknown: return 0
      case .findFound: return 1
      case .findNotfound: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension DistributedMatchEngine_FindCloudletReply.FindStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [DistributedMatchEngine_FindCloudletReply.FindStatus] = [
    .findUnknown,
    .findFound,
    .findNotfound,
  ]
}

#endif  // swift(>=4.2)

struct DistributedMatchEngine_VerifyLocationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// API version
  var ver: UInt32 {
    get {return _storage._ver}
    set {_uniqueStorage()._ver = newValue}
  }

  /// Session Cookie from RegisterClientRequest
  var sessionCookie: String {
    get {return _storage._sessionCookie}
    set {_uniqueStorage()._sessionCookie = newValue}
  }

  /// The carrier name that user is connected to ("Cellular Carrier Name")
  var carrierName: String {
    get {return _storage._carrierName}
    set {_uniqueStorage()._carrierName = newValue}
  }

  /// The GPS location to verify
  var gpsLocation: DistributedMatchEngine_Loc {
    get {return _storage._gpsLocation ?? DistributedMatchEngine_Loc()}
    set {_uniqueStorage()._gpsLocation = newValue}
  }
  /// Returns true if `gpsLocation` has been explicitly set.
  var hasGpsLocation: Bool {return _storage._gpsLocation != nil}
  /// Clears the value of `gpsLocation`. Subsequent reads from it will return its default value.
  mutating func clearGpsLocation() {_uniqueStorage()._gpsLocation = nil}

  /// token used for location verification, app must retrieve from TokenServerURI
  var verifyLocToken: String {
    get {return _storage._verifyLocToken}
    set {_uniqueStorage()._verifyLocToken = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct DistributedMatchEngine_VerifyLocationReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// API version
  var ver: UInt32 = 0

  var towerStatus: DistributedMatchEngine_VerifyLocationReply.Tower_Status = .towerUnknown

  var gpsLocationStatus: DistributedMatchEngine_VerifyLocationReply.GPS_Location_Status = .locUnknown

  /// location accuracy, the location is verified to 
  /// be within this number of kilometers.  Negative value
  /// means no verification was done 
  var gpsLocationAccuracyKm: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Status of the reply
  enum Tower_Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case towerUnknown // = 0
    case connectedToSpecifiedTower // = 1
    case notConnectedToSpecifiedTower // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .towerUnknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .towerUnknown
      case 1: self = .connectedToSpecifiedTower
      case 2: self = .notConnectedToSpecifiedTower
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .towerUnknown: return 0
      case .connectedToSpecifiedTower: return 1
      case .notConnectedToSpecifiedTower: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  enum GPS_Location_Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case locUnknown // = 0
    case locVerified // = 1
    case locMismatchSameCountry // = 2
    case locMismatchOtherCountry // = 3
    case locRoamingCountryMatch // = 4
    case locRoamingCountryMismatch // = 5
    case locErrorUnauthorized // = 6
    case locErrorOther // = 7
    case UNRECOGNIZED(Int)

    init() {
      self = .locUnknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .locUnknown
      case 1: self = .locVerified
      case 2: self = .locMismatchSameCountry
      case 3: self = .locMismatchOtherCountry
      case 4: self = .locRoamingCountryMatch
      case 5: self = .locRoamingCountryMismatch
      case 6: self = .locErrorUnauthorized
      case 7: self = .locErrorOther
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .locUnknown: return 0
      case .locVerified: return 1
      case .locMismatchSameCountry: return 2
      case .locMismatchOtherCountry: return 3
      case .locRoamingCountryMatch: return 4
      case .locRoamingCountryMismatch: return 5
      case .locErrorUnauthorized: return 6
      case .locErrorOther: return 7
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension DistributedMatchEngine_VerifyLocationReply.Tower_Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [DistributedMatchEngine_VerifyLocationReply.Tower_Status] = [
    .towerUnknown,
    .connectedToSpecifiedTower,
    .notConnectedToSpecifiedTower,
  ]
}

extension DistributedMatchEngine_VerifyLocationReply.GPS_Location_Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [DistributedMatchEngine_VerifyLocationReply.GPS_Location_Status] = [
    .locUnknown,
    .locVerified,
    .locMismatchSameCountry,
    .locMismatchOtherCountry,
    .locRoamingCountryMatch,
    .locRoamingCountryMismatch,
    .locErrorUnauthorized,
    .locErrorOther,
  ]
}

#endif  // swift(>=4.2)

struct DistributedMatchEngine_GetLocationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// API version
  var ver: UInt32 = 0

  /// Session Cookie from RegisterClientRequest
  var sessionCookie: String = String()

  /// The carrier name that user is connected to ("Cellular Carrier Name")
  var carrierName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct DistributedMatchEngine_GetLocationReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ver: UInt32 {
    get {return _storage._ver}
    set {_uniqueStorage()._ver = newValue}
  }

  var status: DistributedMatchEngine_GetLocationReply.Loc_Status {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  /// The carrier name that user is connected to ("Cellular Carrier Name")
  var carrierName: String {
    get {return _storage._carrierName}
    set {_uniqueStorage()._carrierName = newValue}
  }

  /// The tower that user is currently connected to
  var tower: UInt64 {
    get {return _storage._tower}
    set {_uniqueStorage()._tower = newValue}
  }

  /// The GPS location of the user 
  var networkLocation: DistributedMatchEngine_Loc {
    get {return _storage._networkLocation ?? DistributedMatchEngine_Loc()}
    set {_uniqueStorage()._networkLocation = newValue}
  }
  /// Returns true if `networkLocation` has been explicitly set.
  var hasNetworkLocation: Bool {return _storage._networkLocation != nil}
  /// Clears the value of `networkLocation`. Subsequent reads from it will return its default value.
  mutating func clearNetworkLocation() {_uniqueStorage()._networkLocation = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Status of the reply
  enum Loc_Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case locUnknown // = 0
    case locFound // = 1

    /// The user does not allow his location to be tracked
    case locDenied // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .locUnknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .locUnknown
      case 1: self = .locFound
      case 2: self = .locDenied
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .locUnknown: return 0
      case .locFound: return 1
      case .locDenied: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension DistributedMatchEngine_GetLocationReply.Loc_Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [DistributedMatchEngine_GetLocationReply.Loc_Status] = [
    .locUnknown,
    .locFound,
    .locDenied,
  ]
}

#endif  // swift(>=4.2)

struct DistributedMatchEngine_AppInstListRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// API version
  var ver: UInt32 {
    get {return _storage._ver}
    set {_uniqueStorage()._ver = newValue}
  }

  /// Session Cookie from RegisterClientRequest
  var sessionCookie: String {
    get {return _storage._sessionCookie}
    set {_uniqueStorage()._sessionCookie = newValue}
  }

  /// The carrier name that user is connected to ("Cellular Carrier Name")
  var carrierName: String {
    get {return _storage._carrierName}
    set {_uniqueStorage()._carrierName = newValue}
  }

  /// The GPS location of the user 
  var gpsLocation: DistributedMatchEngine_Loc {
    get {return _storage._gpsLocation ?? DistributedMatchEngine_Loc()}
    set {_uniqueStorage()._gpsLocation = newValue}
  }
  /// Returns true if `gpsLocation` has been explicitly set.
  var hasGpsLocation: Bool {return _storage._gpsLocation != nil}
  /// Clears the value of `gpsLocation`. Subsequent reads from it will return its default value.
  mutating func clearGpsLocation() {_uniqueStorage()._gpsLocation = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct DistributedMatchEngine_Appinstance {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// App Instance Name
  var appname: String = String()

  /// App Instance Version
  var appversion: String = String()

  /// App Instance FQDN
  var fqdn: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct DistributedMatchEngine_CloudletLocation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The carrier name that user is connected to ("Cellular Carrier Name")
  var carrierName: String {
    get {return _storage._carrierName}
    set {_uniqueStorage()._carrierName = newValue}
  }

  /// Cloudlet Name
  var cloudletName: String {
    get {return _storage._cloudletName}
    set {_uniqueStorage()._cloudletName = newValue}
  }

  /// The GPS Location of the user
  var gpsLocation: DistributedMatchEngine_Loc {
    get {return _storage._gpsLocation ?? DistributedMatchEngine_Loc()}
    set {_uniqueStorage()._gpsLocation = newValue}
  }
  /// Returns true if `gpsLocation` has been explicitly set.
  var hasGpsLocation: Bool {return _storage._gpsLocation != nil}
  /// Clears the value of `gpsLocation`. Subsequent reads from it will return its default value.
  mutating func clearGpsLocation() {_uniqueStorage()._gpsLocation = nil}

  /// Distance of cloudlet vs loc in request
  var distance: Double {
    get {return _storage._distance}
    set {_uniqueStorage()._distance = newValue}
  }

  /// App instances
  var appinstances: [DistributedMatchEngine_Appinstance] {
    get {return _storage._appinstances}
    set {_uniqueStorage()._appinstances = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct DistributedMatchEngine_AppInstListReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// API version
  var ver: UInt32 = 0

  var status: DistributedMatchEngine_AppInstListReply.AI_Status = .aiUndefined

  var cloudlets: [DistributedMatchEngine_CloudletLocation] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Status of the reply
  enum AI_Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case aiUndefined // = 0
    case aiSuccess // = 1
    case aiFail // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .aiUndefined
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .aiUndefined
      case 1: self = .aiSuccess
      case 2: self = .aiFail
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .aiUndefined: return 0
      case .aiSuccess: return 1
      case .aiFail: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension DistributedMatchEngine_AppInstListReply.AI_Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [DistributedMatchEngine_AppInstListReply.AI_Status] = [
    .aiUndefined,
    .aiSuccess,
    .aiFail,
  ]
}

#endif  // swift(>=4.2)

struct DistributedMatchEngine_DynamicLocGroupRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ver: UInt32 = 0

  /// Session Cookie from RegisterClientRequest
  var sessionCookie: String = String()

  /// Dynamic Location Group Id
  var lgID: UInt64 = 0

  var commType: DistributedMatchEngine_DynamicLocGroupRequest.DlgCommType = .dlgUndefined

  /// Unused
  var userData: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Use Secure communication or Open with the group
  enum DlgCommType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case dlgUndefined // = 0
    case dlgSecure // = 1
    case dlgOpen // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .dlgUndefined
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .dlgUndefined
      case 1: self = .dlgSecure
      case 2: self = .dlgOpen
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .dlgUndefined: return 0
      case .dlgSecure: return 1
      case .dlgOpen: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension DistributedMatchEngine_DynamicLocGroupRequest.DlgCommType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [DistributedMatchEngine_DynamicLocGroupRequest.DlgCommType] = [
    .dlgUndefined,
    .dlgSecure,
    .dlgOpen,
  ]
}

#endif  // swift(>=4.2)

struct DistributedMatchEngine_DynamicLocGroupReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ver: UInt32 = 0

  /// Status of the reply
  var status: DistributedMatchEngine_ReplyStatus = .rsUndefined

  /// Error Code based on Failure
  var errorCode: UInt32 = 0

  /// Group Cookie for Secure Group Communication
  var groupCookie: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "distributed_match_engine"

extension DistributedMatchEngine_IDTypes: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ID_UNDEFINED"),
    1: .same(proto: "IMEI"),
    2: .same(proto: "MSISDN"),
    3: .same(proto: "IPADDR"),
  ]
}

extension DistributedMatchEngine_ReplyStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RS_UNDEFINED"),
    1: .same(proto: "RS_SUCCESS"),
    2: .same(proto: "RS_FAIL"),
  ]
}

extension DistributedMatchEngine_RegisterClientRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegisterClientRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ver"),
    2: .same(proto: "DevName"),
    3: .same(proto: "AppName"),
    4: .same(proto: "AppVers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.ver)
      case 2: try decoder.decodeSingularStringField(value: &self.devName)
      case 3: try decoder.decodeSingularStringField(value: &self.appName)
      case 4: try decoder.decodeSingularStringField(value: &self.appVers)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ver != 0 {
      try visitor.visitSingularUInt32Field(value: self.ver, fieldNumber: 1)
    }
    if !self.devName.isEmpty {
      try visitor.visitSingularStringField(value: self.devName, fieldNumber: 2)
    }
    if !self.appName.isEmpty {
      try visitor.visitSingularStringField(value: self.appName, fieldNumber: 3)
    }
    if !self.appVers.isEmpty {
      try visitor.visitSingularStringField(value: self.appVers, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DistributedMatchEngine_RegisterClientRequest, rhs: DistributedMatchEngine_RegisterClientRequest) -> Bool {
    if lhs.ver != rhs.ver {return false}
    if lhs.devName != rhs.devName {return false}
    if lhs.appName != rhs.appName {return false}
    if lhs.appVers != rhs.appVers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DistributedMatchEngine_RegisterClientReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegisterClientReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ver"),
    2: .same(proto: "status"),
    3: .same(proto: "SessionCookie"),
    4: .same(proto: "TokenServerURI"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.ver)
      case 2: try decoder.decodeSingularEnumField(value: &self.status)
      case 3: try decoder.decodeSingularStringField(value: &self.sessionCookie)
      case 4: try decoder.decodeSingularStringField(value: &self.tokenServerUri)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ver != 0 {
      try visitor.visitSingularUInt32Field(value: self.ver, fieldNumber: 1)
    }
    if self.status != .rsUndefined {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    if !self.sessionCookie.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionCookie, fieldNumber: 3)
    }
    if !self.tokenServerUri.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenServerUri, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DistributedMatchEngine_RegisterClientReply, rhs: DistributedMatchEngine_RegisterClientReply) -> Bool {
    if lhs.ver != rhs.ver {return false}
    if lhs.status != rhs.status {return false}
    if lhs.sessionCookie != rhs.sessionCookie {return false}
    if lhs.tokenServerUri != rhs.tokenServerUri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DistributedMatchEngine_FindCloudletRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FindCloudletRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ver"),
    2: .same(proto: "SessionCookie"),
    3: .same(proto: "CarrierName"),
    4: .same(proto: "GpsLocation"),
  ]

  fileprivate class _StorageClass {
    var _ver: UInt32 = 0
    var _sessionCookie: String = String()
    var _carrierName: String = String()
    var _gpsLocation: DistributedMatchEngine_Loc? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _ver = source._ver
      _sessionCookie = source._sessionCookie
      _carrierName = source._carrierName
      _gpsLocation = source._gpsLocation
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt32Field(value: &_storage._ver)
        case 2: try decoder.decodeSingularStringField(value: &_storage._sessionCookie)
        case 3: try decoder.decodeSingularStringField(value: &_storage._carrierName)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._gpsLocation)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._ver != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._ver, fieldNumber: 1)
      }
      if !_storage._sessionCookie.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sessionCookie, fieldNumber: 2)
      }
      if !_storage._carrierName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._carrierName, fieldNumber: 3)
      }
      if let v = _storage._gpsLocation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DistributedMatchEngine_FindCloudletRequest, rhs: DistributedMatchEngine_FindCloudletRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._ver != rhs_storage._ver {return false}
        if _storage._sessionCookie != rhs_storage._sessionCookie {return false}
        if _storage._carrierName != rhs_storage._carrierName {return false}
        if _storage._gpsLocation != rhs_storage._gpsLocation {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DistributedMatchEngine_FindCloudletReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FindCloudletReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ver"),
    2: .same(proto: "status"),
    3: .same(proto: "FQDN"),
    4: .same(proto: "ports"),
    5: .standard(proto: "cloudlet_location"),
  ]

  fileprivate class _StorageClass {
    var _ver: UInt32 = 0
    var _status: DistributedMatchEngine_FindCloudletReply.FindStatus = .findUnknown
    var _fqdn: String = String()
    var _ports: [DistributedMatchEngine_AppPort] = []
    var _cloudletLocation: DistributedMatchEngine_Loc? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _ver = source._ver
      _status = source._status
      _fqdn = source._fqdn
      _ports = source._ports
      _cloudletLocation = source._cloudletLocation
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt32Field(value: &_storage._ver)
        case 2: try decoder.decodeSingularEnumField(value: &_storage._status)
        case 3: try decoder.decodeSingularStringField(value: &_storage._fqdn)
        case 4: try decoder.decodeRepeatedMessageField(value: &_storage._ports)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._cloudletLocation)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._ver != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._ver, fieldNumber: 1)
      }
      if _storage._status != .findUnknown {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 2)
      }
      if !_storage._fqdn.isEmpty {
        try visitor.visitSingularStringField(value: _storage._fqdn, fieldNumber: 3)
      }
      if !_storage._ports.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._ports, fieldNumber: 4)
      }
      if let v = _storage._cloudletLocation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DistributedMatchEngine_FindCloudletReply, rhs: DistributedMatchEngine_FindCloudletReply) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._ver != rhs_storage._ver {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._fqdn != rhs_storage._fqdn {return false}
        if _storage._ports != rhs_storage._ports {return false}
        if _storage._cloudletLocation != rhs_storage._cloudletLocation {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DistributedMatchEngine_FindCloudletReply.FindStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FIND_UNKNOWN"),
    1: .same(proto: "FIND_FOUND"),
    2: .same(proto: "FIND_NOTFOUND"),
  ]
}

extension DistributedMatchEngine_VerifyLocationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VerifyLocationRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ver"),
    2: .same(proto: "SessionCookie"),
    3: .same(proto: "CarrierName"),
    4: .same(proto: "GpsLocation"),
    5: .same(proto: "VerifyLocToken"),
  ]

  fileprivate class _StorageClass {
    var _ver: UInt32 = 0
    var _sessionCookie: String = String()
    var _carrierName: String = String()
    var _gpsLocation: DistributedMatchEngine_Loc? = nil
    var _verifyLocToken: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _ver = source._ver
      _sessionCookie = source._sessionCookie
      _carrierName = source._carrierName
      _gpsLocation = source._gpsLocation
      _verifyLocToken = source._verifyLocToken
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt32Field(value: &_storage._ver)
        case 2: try decoder.decodeSingularStringField(value: &_storage._sessionCookie)
        case 3: try decoder.decodeSingularStringField(value: &_storage._carrierName)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._gpsLocation)
        case 5: try decoder.decodeSingularStringField(value: &_storage._verifyLocToken)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._ver != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._ver, fieldNumber: 1)
      }
      if !_storage._sessionCookie.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sessionCookie, fieldNumber: 2)
      }
      if !_storage._carrierName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._carrierName, fieldNumber: 3)
      }
      if let v = _storage._gpsLocation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._verifyLocToken.isEmpty {
        try visitor.visitSingularStringField(value: _storage._verifyLocToken, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DistributedMatchEngine_VerifyLocationRequest, rhs: DistributedMatchEngine_VerifyLocationRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._ver != rhs_storage._ver {return false}
        if _storage._sessionCookie != rhs_storage._sessionCookie {return false}
        if _storage._carrierName != rhs_storage._carrierName {return false}
        if _storage._gpsLocation != rhs_storage._gpsLocation {return false}
        if _storage._verifyLocToken != rhs_storage._verifyLocToken {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DistributedMatchEngine_VerifyLocationReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VerifyLocationReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ver"),
    2: .standard(proto: "tower_status"),
    3: .standard(proto: "gps_location_status"),
    4: .standard(proto: "GPS_Location_Accuracy_KM"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.ver)
      case 2: try decoder.decodeSingularEnumField(value: &self.towerStatus)
      case 3: try decoder.decodeSingularEnumField(value: &self.gpsLocationStatus)
      case 4: try decoder.decodeSingularDoubleField(value: &self.gpsLocationAccuracyKm)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ver != 0 {
      try visitor.visitSingularUInt32Field(value: self.ver, fieldNumber: 1)
    }
    if self.towerStatus != .towerUnknown {
      try visitor.visitSingularEnumField(value: self.towerStatus, fieldNumber: 2)
    }
    if self.gpsLocationStatus != .locUnknown {
      try visitor.visitSingularEnumField(value: self.gpsLocationStatus, fieldNumber: 3)
    }
    if self.gpsLocationAccuracyKm != 0 {
      try visitor.visitSingularDoubleField(value: self.gpsLocationAccuracyKm, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DistributedMatchEngine_VerifyLocationReply, rhs: DistributedMatchEngine_VerifyLocationReply) -> Bool {
    if lhs.ver != rhs.ver {return false}
    if lhs.towerStatus != rhs.towerStatus {return false}
    if lhs.gpsLocationStatus != rhs.gpsLocationStatus {return false}
    if lhs.gpsLocationAccuracyKm != rhs.gpsLocationAccuracyKm {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DistributedMatchEngine_VerifyLocationReply.Tower_Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TOWER_UNKNOWN"),
    1: .same(proto: "CONNECTED_TO_SPECIFIED_TOWER"),
    2: .same(proto: "NOT_CONNECTED_TO_SPECIFIED_TOWER"),
  ]
}

extension DistributedMatchEngine_VerifyLocationReply.GPS_Location_Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LOC_UNKNOWN"),
    1: .same(proto: "LOC_VERIFIED"),
    2: .same(proto: "LOC_MISMATCH_SAME_COUNTRY"),
    3: .same(proto: "LOC_MISMATCH_OTHER_COUNTRY"),
    4: .same(proto: "LOC_ROAMING_COUNTRY_MATCH"),
    5: .same(proto: "LOC_ROAMING_COUNTRY_MISMATCH"),
    6: .same(proto: "LOC_ERROR_UNAUTHORIZED"),
    7: .same(proto: "LOC_ERROR_OTHER"),
  ]
}

extension DistributedMatchEngine_GetLocationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetLocationRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ver"),
    2: .same(proto: "SessionCookie"),
    3: .same(proto: "CarrierName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.ver)
      case 2: try decoder.decodeSingularStringField(value: &self.sessionCookie)
      case 3: try decoder.decodeSingularStringField(value: &self.carrierName)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ver != 0 {
      try visitor.visitSingularUInt32Field(value: self.ver, fieldNumber: 1)
    }
    if !self.sessionCookie.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionCookie, fieldNumber: 2)
    }
    if !self.carrierName.isEmpty {
      try visitor.visitSingularStringField(value: self.carrierName, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DistributedMatchEngine_GetLocationRequest, rhs: DistributedMatchEngine_GetLocationRequest) -> Bool {
    if lhs.ver != rhs.ver {return false}
    if lhs.sessionCookie != rhs.sessionCookie {return false}
    if lhs.carrierName != rhs.carrierName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DistributedMatchEngine_GetLocationReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetLocationReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ver"),
    2: .same(proto: "Status"),
    3: .same(proto: "CarrierName"),
    4: .same(proto: "Tower"),
    5: .same(proto: "NetworkLocation"),
  ]

  fileprivate class _StorageClass {
    var _ver: UInt32 = 0
    var _status: DistributedMatchEngine_GetLocationReply.Loc_Status = .locUnknown
    var _carrierName: String = String()
    var _tower: UInt64 = 0
    var _networkLocation: DistributedMatchEngine_Loc? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _ver = source._ver
      _status = source._status
      _carrierName = source._carrierName
      _tower = source._tower
      _networkLocation = source._networkLocation
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt32Field(value: &_storage._ver)
        case 2: try decoder.decodeSingularEnumField(value: &_storage._status)
        case 3: try decoder.decodeSingularStringField(value: &_storage._carrierName)
        case 4: try decoder.decodeSingularUInt64Field(value: &_storage._tower)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._networkLocation)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._ver != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._ver, fieldNumber: 1)
      }
      if _storage._status != .locUnknown {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 2)
      }
      if !_storage._carrierName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._carrierName, fieldNumber: 3)
      }
      if _storage._tower != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._tower, fieldNumber: 4)
      }
      if let v = _storage._networkLocation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DistributedMatchEngine_GetLocationReply, rhs: DistributedMatchEngine_GetLocationReply) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._ver != rhs_storage._ver {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._carrierName != rhs_storage._carrierName {return false}
        if _storage._tower != rhs_storage._tower {return false}
        if _storage._networkLocation != rhs_storage._networkLocation {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DistributedMatchEngine_GetLocationReply.Loc_Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LOC_UNKNOWN"),
    1: .same(proto: "LOC_FOUND"),
    2: .same(proto: "LOC_DENIED"),
  ]
}

extension DistributedMatchEngine_AppInstListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AppInstListRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ver"),
    2: .same(proto: "SessionCookie"),
    3: .same(proto: "CarrierName"),
    4: .same(proto: "GpsLocation"),
  ]

  fileprivate class _StorageClass {
    var _ver: UInt32 = 0
    var _sessionCookie: String = String()
    var _carrierName: String = String()
    var _gpsLocation: DistributedMatchEngine_Loc? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _ver = source._ver
      _sessionCookie = source._sessionCookie
      _carrierName = source._carrierName
      _gpsLocation = source._gpsLocation
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt32Field(value: &_storage._ver)
        case 2: try decoder.decodeSingularStringField(value: &_storage._sessionCookie)
        case 3: try decoder.decodeSingularStringField(value: &_storage._carrierName)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._gpsLocation)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._ver != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._ver, fieldNumber: 1)
      }
      if !_storage._sessionCookie.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sessionCookie, fieldNumber: 2)
      }
      if !_storage._carrierName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._carrierName, fieldNumber: 3)
      }
      if let v = _storage._gpsLocation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DistributedMatchEngine_AppInstListRequest, rhs: DistributedMatchEngine_AppInstListRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._ver != rhs_storage._ver {return false}
        if _storage._sessionCookie != rhs_storage._sessionCookie {return false}
        if _storage._carrierName != rhs_storage._carrierName {return false}
        if _storage._gpsLocation != rhs_storage._gpsLocation {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DistributedMatchEngine_Appinstance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Appinstance"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Appname"),
    2: .same(proto: "Appversion"),
    3: .same(proto: "FQDN"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.appname)
      case 2: try decoder.decodeSingularStringField(value: &self.appversion)
      case 3: try decoder.decodeSingularStringField(value: &self.fqdn)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.appname.isEmpty {
      try visitor.visitSingularStringField(value: self.appname, fieldNumber: 1)
    }
    if !self.appversion.isEmpty {
      try visitor.visitSingularStringField(value: self.appversion, fieldNumber: 2)
    }
    if !self.fqdn.isEmpty {
      try visitor.visitSingularStringField(value: self.fqdn, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DistributedMatchEngine_Appinstance, rhs: DistributedMatchEngine_Appinstance) -> Bool {
    if lhs.appname != rhs.appname {return false}
    if lhs.appversion != rhs.appversion {return false}
    if lhs.fqdn != rhs.fqdn {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DistributedMatchEngine_CloudletLocation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CloudletLocation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "CarrierName"),
    2: .same(proto: "CloudletName"),
    3: .same(proto: "GpsLocation"),
    4: .same(proto: "Distance"),
    5: .same(proto: "Appinstances"),
  ]

  fileprivate class _StorageClass {
    var _carrierName: String = String()
    var _cloudletName: String = String()
    var _gpsLocation: DistributedMatchEngine_Loc? = nil
    var _distance: Double = 0
    var _appinstances: [DistributedMatchEngine_Appinstance] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _carrierName = source._carrierName
      _cloudletName = source._cloudletName
      _gpsLocation = source._gpsLocation
      _distance = source._distance
      _appinstances = source._appinstances
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._carrierName)
        case 2: try decoder.decodeSingularStringField(value: &_storage._cloudletName)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._gpsLocation)
        case 4: try decoder.decodeSingularDoubleField(value: &_storage._distance)
        case 5: try decoder.decodeRepeatedMessageField(value: &_storage._appinstances)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._carrierName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._carrierName, fieldNumber: 1)
      }
      if !_storage._cloudletName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cloudletName, fieldNumber: 2)
      }
      if let v = _storage._gpsLocation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if _storage._distance != 0 {
        try visitor.visitSingularDoubleField(value: _storage._distance, fieldNumber: 4)
      }
      if !_storage._appinstances.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._appinstances, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DistributedMatchEngine_CloudletLocation, rhs: DistributedMatchEngine_CloudletLocation) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._carrierName != rhs_storage._carrierName {return false}
        if _storage._cloudletName != rhs_storage._cloudletName {return false}
        if _storage._gpsLocation != rhs_storage._gpsLocation {return false}
        if _storage._distance != rhs_storage._distance {return false}
        if _storage._appinstances != rhs_storage._appinstances {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DistributedMatchEngine_AppInstListReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AppInstListReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ver"),
    2: .same(proto: "Status"),
    3: .same(proto: "Cloudlets"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.ver)
      case 2: try decoder.decodeSingularEnumField(value: &self.status)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.cloudlets)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ver != 0 {
      try visitor.visitSingularUInt32Field(value: self.ver, fieldNumber: 1)
    }
    if self.status != .aiUndefined {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    if !self.cloudlets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cloudlets, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DistributedMatchEngine_AppInstListReply, rhs: DistributedMatchEngine_AppInstListReply) -> Bool {
    if lhs.ver != rhs.ver {return false}
    if lhs.status != rhs.status {return false}
    if lhs.cloudlets != rhs.cloudlets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DistributedMatchEngine_AppInstListReply.AI_Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AI_UNDEFINED"),
    1: .same(proto: "AI_SUCCESS"),
    2: .same(proto: "AI_FAIL"),
  ]
}

extension DistributedMatchEngine_DynamicLocGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DynamicLocGroupRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ver"),
    2: .same(proto: "SessionCookie"),
    3: .same(proto: "LgId"),
    11: .same(proto: "CommType"),
    12: .same(proto: "UserData"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.ver)
      case 2: try decoder.decodeSingularStringField(value: &self.sessionCookie)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.lgID)
      case 11: try decoder.decodeSingularEnumField(value: &self.commType)
      case 12: try decoder.decodeSingularStringField(value: &self.userData)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ver != 0 {
      try visitor.visitSingularUInt32Field(value: self.ver, fieldNumber: 1)
    }
    if !self.sessionCookie.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionCookie, fieldNumber: 2)
    }
    if self.lgID != 0 {
      try visitor.visitSingularUInt64Field(value: self.lgID, fieldNumber: 3)
    }
    if self.commType != .dlgUndefined {
      try visitor.visitSingularEnumField(value: self.commType, fieldNumber: 11)
    }
    if !self.userData.isEmpty {
      try visitor.visitSingularStringField(value: self.userData, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DistributedMatchEngine_DynamicLocGroupRequest, rhs: DistributedMatchEngine_DynamicLocGroupRequest) -> Bool {
    if lhs.ver != rhs.ver {return false}
    if lhs.sessionCookie != rhs.sessionCookie {return false}
    if lhs.lgID != rhs.lgID {return false}
    if lhs.commType != rhs.commType {return false}
    if lhs.userData != rhs.userData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DistributedMatchEngine_DynamicLocGroupRequest.DlgCommType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DlgUndefined"),
    1: .same(proto: "DlgSecure"),
    2: .same(proto: "DlgOpen"),
  ]
}

extension DistributedMatchEngine_DynamicLocGroupReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DynamicLocGroupReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ver"),
    2: .same(proto: "status"),
    3: .same(proto: "ErrorCode"),
    5: .same(proto: "GroupCookie"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.ver)
      case 2: try decoder.decodeSingularEnumField(value: &self.status)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.errorCode)
      case 5: try decoder.decodeSingularStringField(value: &self.groupCookie)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ver != 0 {
      try visitor.visitSingularUInt32Field(value: self.ver, fieldNumber: 1)
    }
    if self.status != .rsUndefined {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    if self.errorCode != 0 {
      try visitor.visitSingularUInt32Field(value: self.errorCode, fieldNumber: 3)
    }
    if !self.groupCookie.isEmpty {
      try visitor.visitSingularStringField(value: self.groupCookie, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DistributedMatchEngine_DynamicLocGroupReply, rhs: DistributedMatchEngine_DynamicLocGroupReply) -> Bool {
    if lhs.ver != rhs.ver {return false}
    if lhs.status != rhs.status {return false}
    if lhs.errorCode != rhs.errorCode {return false}
    if lhs.groupCookie != rhs.groupCookie {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
